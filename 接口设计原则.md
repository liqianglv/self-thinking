# 接口设计的原则及一些例子
总体设计原则： 封装，高内聚，低耦合

## 1、接口的单一职责原则
单一职责可以理解为每个接口仅暴露需要的最少信息，符合低耦合的设计原则。
### 例子
钱袋宝账户，类似于支付宝账户。注册钱袋宝账户，对个人用户而言，仅需要用户的身份证号，银行卡，手机号码等信息；对于商户用户而言，需要商户的营业执照，办公地址等商业相关信息。虽然都是注册账户功能，但是应该按照个人用户注册和商户用户注册，设计2个接口。这样避免了多余信息的暴露（个人用户不需要知道商业用户的注册信息），防止单个接口种出现多个控制流。

## 2、定义业务接口，而不是实现接口
接口定义，包括接口名称，参数名称等应按照业务含义和名称来定义，而不是按照暴露内部实现的方式来定义。
本质上还是高内聚，低耦合
### 例子
出租车线上打车系统，司机的收入除了订单的收入，还包括客服主动扣款（比如因为记账错误，因为反作弊等），客服主动补款（比如漏记账，司机协助测试等），针对司机的运营活动收入等。不好的设计方案：
方法一: 注册一个通用的司机增加收入接口，调用方传入司机id, 收入类型，收入金额等信息，多个业务可以共用这个接口
```java
   boolean addDriverMoney(String driverId, int moneyType, int money, String operator, Date opeTime, ...);
```   
这种接口设计是典型的面相实现的设计，接口内容暴露了接口实现的某些细节，存在的问题：
* 暴露了接口实现（例子中司机收入）相关的细节，违背了比如 moneyType， 收入类型作为司机收入内部数据，不允许外围系统感知， 这违背了封装性原则。
* 职责不单一，对于不同的收入类型，可能需要不同的前置处理，实现接口违反了单一职责原则

比较合理的设计是定义业务接口，接口反应业务
```java
   boolean systemReward(String driverId, int rewardMoney, String operator, Date opeTime, ...);  //系统补款功能
   boolean systemFine(String driverId，int fineMoney, String operator, Date opeTime, ...);  //系统罚款功能
   ...
```
## 3、接口控制数据和业务数据分离
比较典型的外部接口有如下几类：
+ 面向最终用户的接口，比如直接提供给APP或者H5使用的接口。
+ 面向外部系统的接口，主要是后台交互接口。
+ 微服务面向外部模块暴露的接口。

对外暴露的接口，除了接口本色很提供的功能外，考虑到外部系统的安全性，流量等，往往还需要一些业务之外的字段用于非业务功能的实现，常见的包括：安全性控制，流量控制，授权认证，版本控制等。这些额外的控制数据，最好设计为一个单独的统一的对象，作为接口参数的一部分。这样设计主要有2个好处：
- 便于控制流的面向切面实现，业务开发代码只需要关注业务，实现功能的解耦。比如常见的 http servlet filter， springMvc 的 intercepter 等。
- 控制数据作为单独的统一对象，方便扩展。如果接口需要增加通用的控制字段，只需要修改这个统一的对象，而不需要每个接口都重新设计对象。

本质上讲，还是高内聚，低耦合。

## 4、面向用户的接口，尽量多的收集用户相关的数据：用户数据都是有用的数据。
接口，以及系统提供的功能，往往随着系统的逐渐完善，需要向更智能，更可用化的方向演进，这些都需要用户数据的支持。系统设计初期很多无用的数据，极可能就是后期接口改进需要的数据，在不方便做全量升级的系统中，接口尽量一开始就收集比较全面的用户数据，用于功能的扩展。
例子：
租车功能，需要用户输入租车的开始和结束时间，租车地址和还车地址，系统进行库存判断，并输出可选择的产品信息。随着系统的演进，以及增加转化率的需求，后期系统要求能够个性化推荐取车还车地址。个性化推荐取还车地址，除了用户的订单及查询历史地址外，很合理的推荐方案就是目前用户所在的位置，前期完全无用的数据后续很可能就是非常有用的数据。
